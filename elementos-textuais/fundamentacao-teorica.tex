\chapter{Fundamentação Teórica}
\label{cap:fundamentacao-teorica}

A construção de um simulador robótico exige a interseção de conhecimentos de diversas áreas, notadamente a Robótica, a Álgebra Linear e a Computação Gráfica. Este capítulo estabelece as bases teóricas necessárias para a compreensão dos algoritmos implementados, discutindo desde a modelagem matemática do movimento até as técnicas de renderização tridimensional.

\section{Modelagem Cinemática de Manipuladores}
\label{sec:cinematica}

A cinemática é o ramo da mecânica que descreve o movimento dos corpos sem se preocupar com as forças que o causam. No contexto de braços robóticos, ela é dividida fundamentalmente em dois problemas: a cinemática direta e a inversa \cite{spong2020}.

\subsection{Parâmetros de Denavit-Hartenberg (D-H)}
Para representar geometricamente as ligações entre os elos de um robô, utiliza-se a convenção de Denavit-Hartenberg (D-H). Este método padroniza a descrição da geometria do robô através de quatro parâmetros para cada elo: comprimento do elo ($a$), torção do elo ($\alpha$), deslocamento do elo ($d$) e ângulo da junta ($\theta$) \cite{craig2017}. 



A partir desses parâmetros, constroem-se matrizes de transformação homogênea que, quando multiplicadas sequencialmente, permitem calcular a posição e orientação do efetuador final em relação à base.

\subsection{Cinemática Inversa e Algoritmo FABRIK}
Enquanto a cinemática direta possui solução única e analítica, a cinemática inversa — encontrar os ângulos das juntas para uma dada posição final — é um problema complexo e não linear, frequentemente admitindo múltiplas soluções. 

Para aplicações em tempo real, métodos iterativos são preferíveis devido ao seu baixo custo computacional. Neste trabalho, destaca-se o algoritmo FABRIK (\textit{Forward And Backward Reaching Inverse Kinematics}). Diferente dos métodos baseados no Jacobiano, o FABRIK utiliza uma abordagem geométrica heurística, ajustando iterativamente as posições das juntas para minimizar o erro em relação ao alvo, garantindo convergência rápida e estabilidade visual \cite{aristidou2011fabrik}.

\section{Simulação Física e Detecção de Colisão}
\label{sec:colisao}

O realismo de uma simulação depende não apenas do movimento visual, mas da interação física dos objetos. A detecção de colisão impede que o robô atravesse a si mesmo (auto-colisão) ou objetos do cenário.

O algoritmo GJK (\textit{Gilbert-Johnson-Keerthi}) é o padrão da indústria para detectar a intersecção entre poliedros convexos. Ele utiliza a soma de Minkowski para determinar, de forma eficiente, se dois objetos compartilham espaço \cite{gjk1988}. Quando uma colisão é detectada, o algoritmo EPA (\textit{Expanding Polytope Algorithm}) é frequentemente empregado para calcular a profundidade de penetração e o vetor de repulsão necessário para corrigir a posição física \cite{van1999epa}.

\section{Tecnologias de Desenvolvimento}
\label{sec:tecnologias}

A implementação do software baseia-se em um conjunto de bibliotecas de alto desempenho, escolhidas para garantir a fluidez da simulação em hardware convencional.

\subsection{Renderização com OpenGL e GLM}
A visualização tridimensional é realizada via OpenGL, uma API gráfica multiplataforma que interage diretamente com a GPU \cite{opengl2015}. Para abstrair a complexidade matemática das operações vetoriais e matriciais necessárias tanto para o OpenGL quanto para os cálculos de cinemática, utiliza-se a biblioteca GLM (\textit{OpenGL Mathematics}) \cite{glm2016}.



\subsection{Interface Gráfica e Gerenciamento de Janelas}
A interação do usuário é mediada pela biblioteca \textit{Dear ImGui}, que adota o paradigma de "Immediate Mode GUI". Isso permite que os elementos da interface (botões, sliders, gráficos) sejam renderizados juntamente com a cena 3D, facilitando a criação de ferramentas de depuração em tempo real \cite{imgui}. O gerenciamento do contexto da janela e dos eventos de entrada (teclado/mouse) fica a cargo da biblioteca SDL2 \cite{sdl2}, garantindo portabilidade entre sistemas operacionais.