\chapter{Metodologia}
\label{chap:metodologia}

O desenvolvimento do software de simulação 3D para o braço robótico Mitsubishi RV-2SDB/RV-2SQB seguiu uma abordagem estruturada e iterativa, com ciclos de implementação, teste e validação. O foco principal foi garantir um sistema funcional, modular e reutilizável para fins educacionais e de pesquisa. As etapas da metodologia são descritas nas subseções seguintes.

\section{Definição dos Requisitos}
\label{sec:exemplo-de-algoritmos-e-figuras}

Inicialmente, foram identificados os requisitos funcionais e não funcionais do sistema, baseados nas necessidades de simulação e ensino do robô:

\begin{alineascomnumero}
    \item Controle Interativo: Operação via teclado e mouse para ajustar ângulos das juntas.
    \item Simulação 3D: Visualização em tempo real dos movimentos do robô.
    \item Parâmetros Realistas: Configurações baseadas nas especificações reais (e.g., ±240° para J1).
    \item Interface Gráfica: Exibição de parâmetros e controles interativos.
    \item Open Source: Uso de bibliotecas livres.
    \item Desempenho: Renderização fluida e estabilidade.
\end{alineascomnumero}

\section{Seleção das Tecnologias}
Inicialmente, foram identificados os requisitos funcionais e não funcionais do sistema, baseados nas necessidades de simulação, ensino e uso prático do robô. Os requisitos principais foram:

\begin{alineascomnumero}
	\item OpenGL e SDL: Renderização 3D e gerenciamento de janelas.
	\item GLM: Algebra linear em espaço tridimensional.
	\item ImGui: Interface gráfica interativa.
	\item fmt: Formatação de strings e logging.
	\item xmake: Gerenciamento de compilação.
\end{alineascomnumero}

\section{Modelagem do Robô}

Desenvolveu-se um modelo cinemático com 6 juntas, utilizando dados do manual do robô (e.g., ±240° para J1, velocidade máxima de 4.490 mm/s).
Comprimentos aproximados dos elos foram definidos (0.2m, 0.3m, 0.25m, 0.15m, 0.1m, 0.05m), a serem refinados com dados reais. 
A cinemática inversa foi implementada para calcular posições com base nos ângulos das juntas.

\begin{itemize}
    \item representação de cada junta (tipo, limite angular, velocidade máxima);
    \item definição da cadeia cinemática por parâmetros Denavit--Hartenberg (D--H);
    \item representação geométrica das peças para detecção de colisão (caixas delimitadoras e malhas simplificadas);
    \item exportação/esquema para importar modelos URDF/GLTF quando disponível.
\end{itemize}

 \begin{figure}[h!]
    \centering
	\Caption{\label{fig:Figura-1} Modelo 3D renderizado do Robô}	
	\UNIFORfig{}{
		\fbox{\includegraphics[width=8cm]{figuras/figura-2}}
	}{
		\Fonte{Elaborado pelo autor}			
	}	
\end{figure}

\section{Implementação do Software}

O software foi implementado em C++, com módulos separados:

\begin{alineascomnumero}
    \item Renderização: Carregamento e renderização do modelo 3D usando OpenGL e Assimp.
    \item Input: Gerenciamento de entradas via SDL (teclado, mouse).
    \item Simulação: Cálculo de transformações cinemáticas com GLM e modelagem física para simulação realista.
    \item Interface Gráfica: Exibição e ajuste de parâmetros via ImGui.
\end{alineascomnumero}

Implementando estes algoritmos para cinemática e simulação física:

%\begin{algorithm}[H]
%	\Entrada{o proprio texto}
%	\Saida{como escrever algoritmos com \LaTeX2e }
%	\Inicio{
%		inicializa\c{c}\~ao\;
%		\Repita{fim do texto}{
%			leia o atual\;
%			\Se{entendeu}{
%				vá para o próximo\;
%				próximo se torna o atual\;}
%			\Senao{volte ao início da seção\;}
%		}
%	}
%	\caption{Exemplo de Algoritmo Versao 02}
%\end{algorithm}

%\begin{algorithm}
%	\begin{algorithmic}
%	\Entrada{o proprio texto}
%	\Saida{como escrever algoritmos com \LaTeX2e }	
%	\end{algorithmic}
%\end{algorithm}

Exemplo de alíneas com números:

%\begin{alineascomnumero}
%	\item Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nunc dictum sed tortor nec viverra.
%	\item Praesent vitae nulla varius, pulvinar quam at, dapibus nisi. Aenean in commodo tellus. Mauris molestie est sed justo malesuada, quis feugiat tellus venenatis.
%	\item Praesent quis erat eleifend, lacinia turpis in, tristique tellus. Nunc dictum sed tortor nec viverra.
%	\item Mauris facilisis odio eu ornare tempor. Nunc dictum sed tortor nec viverra.
%	\item Curabitur convallis odio at eros consequat pretium.
%\end{alineascomnumero}

%\lipsum[12]

\begin{table}[h!]	
	\centering
	\Caption{\label{tab:internal}Internal exon scores}	
	\IBGEtab{}{
		\begin{tabular}{cll}
			\toprule
			Ranking & Exon Coverage & Splice Site Support\\
			\midrule \midrule
			E1 & Complete coverage by a single transcript & Both splice sites\\
			E2 & Complete coverage by more than a single transcript & Both splice sites\\
			E3 & Partial coverage & Both splice sites\\
			E4 & Partial coverage & One splice site\\
			E5 & Complete or partial coverage & No splice sites\\
			E6 & No coverage & No splice sites\\
			\bottomrule
		\end{tabular}
	}{
	\Fonte{os autores}
}
\end{table}

\section{Algoritmos e embasamento matemático}

\subsection{Algoritmos de Simulação Robótica}

Os seguintes algoritmos foram implementados para o software de simulação 3D:

\subsubsection{Algoritmo FABRIK}

O algoritmo FABRIK (Forward and Backward Reaching Inverse Kinematics) é utilizado para resolver o problema de cinemática inversa, determinando os ângulos das juntas necessários para posicionar o efetuador final do robô em uma posição alvo específica. Este algoritmo opera em duas fases: uma fase forward que estende a cadeia cinemática em direção ao alvo, e uma fase backward que ajusta as posições das juntas para manter os comprimentos dos elos constantes, sendo particularmente eficaz por sua simplicidade computacional e capacidade de lidar com múltiplos graus de liberdade em tempo real.

\begin{algorithm}[h!]
	\SetSpacedAlgorithm
	\caption{\label{alg:fabrik}Algoritmo FABRIK - Forward and Backward Reaching Inverse Kinematics}
	\Entrada{posição alvo, posições das juntas, comprimentos dos elos}
	\Saida{ângulos das juntas para alcançar a posição alvo}
	\Inicio{
		\Para{cada iteração}{
			// Fase Forward (para frente)
			posição\_atual $\leftarrow$ posição\_base\;
			\Para{i = 1 até número\_de\_juntas}{
				distância $\leftarrow$ |posição\_alvo - posição\_atual|\;
				\Se{distância > comprimento\_elo[i]}{
					posição\_atual $\leftarrow$ posição\_atual + (comprimento\_elo[i] / distância) * (posição\_alvo - posição\_atual)\;
				}
				\Senao{
					posição\_atual $\leftarrow$ posição\_alvo\;
				}
			}
			// Fase Backward (para trás)
			posição\_atual $\leftarrow$ posição\_alvo\;
			\Para{i = número\_de\_juntas até 1}{
				distância $\leftarrow$ |posição\_anterior - posição\_atual|\;
				\Se{distância > comprimento\_elo[i]}{
					posição\_atual $\leftarrow$ posição\_atual + (comprimento\_elo[i] / distância) * (posição\_anterior - posição\_atual)\;
				}
				\Senao{
					posição\_atual $\leftarrow$ posição\_anterior\;
				}
			}
		}
		calcular\_ângulos\_das\_juntas()\;
	}	
\end{algorithm}

\subsubsection{Algoritmo GGD}

O algoritmo GGD (Gradient Descent com Coordenação Cíclica) é empregado para otimização de parâmetros e ajuste fino dos movimentos, permitindo ajustar automaticamente os parâmetros do sistema como velocidades e acelerações para melhorar a suavidade e precisão dos movimentos simulados, sendo especialmente útil para encontrar configurações ótimas que minimizem o consumo de energia ou maximizem a eficiência dos movimentos do robô.

\begin{algorithm}[h!]
	\SetSpacedAlgorithm
	\caption{\label{alg:ggd}Algoritmo GGD - Gradient Descent com Coordenação Cíclica}
	\Entrada{função objetivo, parâmetros iniciais, taxa de aprendizado}
	\Saida{parâmetros otimizados}
	\Inicio{
		parâmetros $\leftarrow$ parâmetros\_iniciais\;
		\Repita{convergência}{
			gradiente $\leftarrow$ calcular\_gradiente(parâmetros)\;
			\Para{cada parâmetro i}{
				parâmetros[i] $\leftarrow$ parâmetros[i] - taxa\_aprendizado * gradiente[i]\;
			}
			erro $\leftarrow$ calcular\_erro(parâmetros)\;
			\Se{erro < threshold}{
				parar\;
			}
		}
	}	
\end{algorithm}

\subsubsection{Algoritmo GJK}

O algoritmo GJK (Gilbert Johnson Keerthi) é responsável pela detecção rápida de colisões, garantindo que o robô não atravesse objetos ou se auto-intersecte durante os movimentos, utilizando conceitos de geometria computacional e análise de simplex para detectar se dois objetos estão em colisão de forma altamente eficiente e em tempo real, permitindo simulações fluidas mesmo com múltiplos objetos no ambiente.

\begin{algorithm}[h!]
	\SetSpacedAlgorithm
	\caption{\label{alg:gjk}Algoritmo GJK - Gilbert Johnson Keerthi para Detecção de Colisão}
	\Entrada{objeto A, objeto B}
	\Saida{colisão detectada (verdadeiro/falso)}
	\Inicio{
		simplex $\leftarrow$ $\emptyset$\;
		direção $\leftarrow$ direção\_inicial\;
		\Repita{simplex contém origem}{
			ponto\_suporte $\leftarrow$ suporte(A, B, direção)\;
			\Se{ponto\_suporte $\cdot$ direção $\leq$ 0}{
				retornar falso\;
			}
			simplex $\leftarrow$ adicionar\_ponto(simplex, ponto\_suporte)\;
			simplex, direção $\leftarrow$ reduzir\_simplex(simplex)\;
		}
		retornar verdadeiro\;
	}	
\end{algorithm}

\subsubsection{Algoritmo EPA}

O algoritmo EPA (Expanding Polytope Algorithm) complementa o GJK calculando informações detalhadas sobre colisões, incluindo a distância de penetração e o vetor de separação, sendo essencial para implementar respostas realistas a colisões como separação automática de objetos ou alertas visuais para o usuário, trabalhando em conjunto com o GJK para fornecer uma solução completa ao problema de detecção e resolução de colisões.

\begin{algorithm}[h!]
	\SetSpacedAlgorithm
	\caption{\label{alg:epa}Algoritmo EPA - Expanding Polytope Algorithm}
	\Entrada{simplex do GJK}
	\Saida{vetor de separação e distância de penetração}
	\Inicio{
		polítopo $\leftarrow$ simplex\;
		\Repita{polítopo não pode ser expandido}{
			aresta\_mais\_próxima $\leftarrow$ encontrar\_aresta\_mais\_próxima\_da\_origem(polítopo)\;
			ponto\_suporte $\leftarrow$ suporte(A, B, normal\_da\_aresta)\;
			distância $\leftarrow$ |ponto\_suporte $\cdot$ normal\_da\_aresta|\;
			\Se{|distância - distância\_anterior| < epsilon}{
				retornar normal\_da\_aresta, distância\;
			}
			polítopo $\leftarrow$ adicionar\_ponto(polítopo, ponto\_suporte)\;
		}
	}	
\end{algorithm}


\subsection{Embasamento Matematico dos Algoritmos de Simulação Robótica}

Os algoritmos implementados cobrem cinemática, detecção de colisão e otimização de movimentos. Abaixo apresenta-se um resumo técnico de cada componente (o trabalho final deve incluir detalhes formais, equações D--H e provas/validações sempre que possível).

\subsubsection{FABRIK (cinemática inversa de alcance para frente e para trás)}
O FABRIK (Forward And Backward Reaching Inverse Kinematics) é um algoritmo heurístico e iterativo para resolver problemas de cinemática inversa. A sua base matemática reside na geometria de vetores e na interpolação linear para ajustar as posições das juntas de uma cadeia cinemática, mantendo os comprimentos dos elos constantes.

O processo iterativo consiste em duas fases:

\begin{itemize}
    \item \textbf{Fase Inversa (Backward Reaching):} A partir do efetuador final, que é movido para a posição alvo ($t$), cada junta $p_i$ é ajustada para manter a distância $d_i$ em relação à junta seguinte $p_{i+1}$. A nova posição de $p_i$ é calculada pela interpolação:
    \begin{equation}
        p_i = (1 - \lambda_i) p_{i+1} + \lambda_i p_i
    \end{equation}
    onde $\lambda_i = \frac{d_i}{|p_{i+1} - p_i|}$.

    \item \textbf{Fase Direta (Forward Reaching):} A partir da junta raiz $p_1$, que é fixada na sua posição original, o processo é repetido em direção ao efetuador final. A posição da junta $p_{i+1}$ é ajustada em relação a $p_i$:
    \begin{equation}
        p_{i+1} = (1 - \lambda_i) p_i + \lambda_i p_{i+1}
    \end{equation}
\end{itemize}
Estas fases são repetidas até que a distância entre o efetuador final e o alvo seja menor que uma tolerância definida.

\subsubsection{GGD (Descida de coordenação cíclica)}
A Descida de Coordenadas Cíclicas (Cyclic Coordinate Descent - CCD) é um algoritmo de otimização que minimiza uma função multivariada, otimizando uma variável de cada vez, mantendo as outras constantes. Este processo é repetido ciclicamente para todas as variáveis até que um mínimo seja alcançado.

Para minimizar uma função $F(x)$ onde $x = (x_1, x_2, ..., x_n)$, o algoritmo atualiza cada coordenada $x_i$ sequencialmente:
\begin{equation}
    x_i^{(k+1)} = \arg\min_{y} F(x_1^{(k+1)}, ..., x_{i-1}^{(k+1)}, y, x_{i+1}^{(k)}, ..., x_n^{(k)})
\end{equation}
onde $k$ é a iteração atual. O algoritmo converge quando a alteração na função objetivo $F(x)$ ou no vetor de parâmetros $x$ se torna insignificante.

\subsubsection{GJK (Gilbert Johnson Keerthi): Cálculo de colisão para simulação física realista}
O algoritmo GJK (Gilbert-Johnson-Keerthi) é um método eficiente para determinar se duas formas convexas estão a colidir. Ele opera procurando iterativamente a origem dentro da Diferença de Minkowski das duas formas.

A Diferença de Minkowski de duas formas convexas, A e B, é definida como:
\begin{equation}
    A - B = \{a - b | a \in A, b \in B\}
\end{equation}
A colisão ocorre se, e somente se, a origem estiver contida em $A - B$. O GJK utiliza uma função de suporte para sondar pontos na Diferença de Minkowski sem a calcular explicitamente:
\begin{equation}
    s_{A-B}(d) = s_A(d) - s_B(-d)
\end{equation}
onde $s_S(d)$ é o ponto no limite da forma $S$ que está mais distante na direção $d$. O algoritmo constrói iterativamente um simplex (um polígono convexo) dentro da Diferença de Minkowski, tentando envolver a origem.

\subsubsection{TSE (Teorema de separação de eixos): Cálculo de colisão para simulação física realista}
O Teorema de Separação de Eixos (Separating Axis Theorem - SAT) afirma que dois objetos convexos não estão a colidir se, e somente se, existir pelo menos uma linha (em 2D) ou plano (em 3D) no qual as projeções dos dois objetos não se sobrepõem. Esta linha ou plano é chamado de "eixo de separação".

Para cada eixo candidato (normal a uma aresta/face), as formas A e B são projetadas, resultando em intervalos 1D $[min_A, max_A]$ e $[min_B, max_B]$. Um eixo de separação é encontrado se:
\begin{equation}
    max_A < min_B \quad \text{ou} \quad max_B < min_A
\end{equation}
Se nenhum eixo de separação for encontrado após testar todos os eixos candidatos, as formas estão a colidir.

\subsubsection{EPA (Algoritmo de expansão de politopo)}
O Algoritmo de Expansão de Politopo (Expanding Polytope Algorithm - EPA) é usado após o GJK detetar uma colisão. O seu objetivo é calcular a profundidade de penetração e o vetor de contacto.

O EPA começa com o simplex final gerado pelo GJK, que contém a origem. Em cada iteração, o algoritmo encontra a face (ou aresta em 2D) do politopo atual que está mais próxima da origem. Usando a normal dessa face como direção, ele consulta a função de suporte da Diferença de Minkowski para encontrar um novo ponto no limite da Diferença de Minkowski. Este ponto é adicionado ao politopo, expandindo-o. O processo termina quando o novo ponto de suporte não está significativamente mais longe do que a face mais próxima, e a distância da origem a essa face é a profundidade de penetração.

\subsubsection{Adição de Minkowski: Função suporte para o algoritmo de GJK}
A Adição de Minkowski (ou Soma de Minkowski) de dois conjuntos de pontos, A e B, é definida como o conjunto de todas as somas de vetores possíveis de um elemento de A e um elemento de B:
\begin{equation}
    A + B = \{a + b | a \in A, b \in B\}
\end{equation}
Esta operação é fundamental para a teoria de deteção de colisão, pois a colisão entre A e B é equivalente à origem estar contida na sua Diferença de Minkowski, $A - B$. A função de suporte do GJK é uma forma eficiente de explorar a Diferença de Minkowski.

\subsubsection{Sistemas de arbitração para simulação}
Os sistemas de arbitragem em simulações gerem o acesso a recursos partilhados ou o controlo entre múltiplos agentes. A sua base matemática varia consoante a estratégia:
\begin{itemize}
    \item \textbf{Baseada em Prioridade:} Acesso é concedido ao agente $k$ com a maior prioridade $P_k$:
    \begin{equation}
        \text{Agente}_k \text{ tal que } P_k = \max_{i \in \text{Requerentes}} (P_i)
    \end{equation}
    \item \textbf{Baseada em Utilidade:} O árbitro maximiza a utilidade total, onde $U_i$ é a utilidade do agente $i$ e $x_i$ é uma variável de decisão binária:
    \begin{equation}
        \max \sum_{i=1}^N U_i \cdot x_i \quad \text{sujeito a} \quad \sum_{i=1}^N x_i \le 1
    \end{equation}
    \item \textbf{Teoria das Filas:} Modela a chegada e o serviço de pedidos de recursos usando distribuições de probabilidade (e.g., Poisson, Exponencial) para analisar métricas como o tempo de espera e o comprimento da fila.
\end{itemize}

\section{Usando Código-fonte}

\lipsum[10]

\lstinputlisting[language=C++,caption={Hello World em C++}]{figuras/main.cpp}

\lipsum[11]

\begin{lstlisting}[language=Java,caption={Hello World em Java}]
public class HelloWorld {
	public static void main(String[] args) {
		System.out.println("Hello World!");
	}
}
\end{lstlisting}
