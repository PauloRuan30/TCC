\chapter{Metodologia}
\label{chap:metodologia}

O desenvolvimento do software de simulação 3D para o braço robótico Mitsubishi RV-2SDB/RV-2SQB seguiu uma abordagem estruturada e iterativa, garantindo a entrega de um sistema funcional e robusto para fins educacionais. As etapas da metodologia são detalhadas a seguir.

\begin{table}[h!]
	\Caption{\label{tabela-ibge} Um Exemplo de tabela alinhada que pode ser longa ou curta, conforme padrão IBGE}%
	\IBGEtab{}{%
		\begin{tabular}{ccc}
			\toprule
			Nome & Nascimento & Documento \\
			\midrule \midrule
			Maria da Silva & 11/11/1111 & 111.111.111-11 \\
			Maria da Silva & 11/11/1111 & 111.111.111-11 \\
			Maria da Silva & 11/11/1111 & 111.111.111-11 \\
			\bottomrule
		\end{tabular}%
	}{%
	\Fonte{Produzido pelos autores}%
	\Nota{Esta é uma nota, que diz que os dados são baseados na
		regressão linear.}%
	\Nota[Anotações]{Uma anotação adicional, seguida de várias outras.}%
}
\end{table}

\section{Definição dos Requisitos}
\label{sec:exemplo-de-algoritmos-e-figuras}

Inicialmente, foram identificados os requisitos funcionais e não funcionais do sistema, baseados nas necessidades de simulação e ensino do robô:

\begin{alineascomnumero}
	\item Controle Interativo: Operação via teclado e mouse para ajustar ângulos das juntas.
    \item Simulação 3D: Visualização em tempo real dos movimentos do robô.
    \item Parâmetros Realistas: Configurações baseadas nas especificações reais (e.g., ±240° para J1).
    \item Interface Gráfica: Exibição de parâmetros e controles interativos.
    \item Open Source: Uso de bibliotecas livres.
    \item Desempenho: Renderização fluida e estabilidade.
\end{alineascomnumero}

\section{Seleção das Tecnologias}
\label{sec:exemplo-de-algoritmos-e-figuras}

Foram selecionadas tecnologias open source adequadas aos requisitos:

\begin{alineascomnumero}
	\item OpenGL e SDL: Renderização 3D e gerenciamento de janelas.
	\item GLM: Algebra linear em espaço tridimensional.
	\item ImGui: Interface gráfica interativa.
	\item fmt: Formatação de strings e logging.
	\item xmake: Gerenciamento de compilação.
\end{alineascomnumero}

\section{Modelagem do Robô}

Desenvolveu-se um modelo cinemático com 6 juntas, utilizando dados do manual do robô (e.g., ±240° para J1, velocidade máxima de 4.490 mm/s).
Comprimentos aproximados dos elos foram definidos (0.2m, 0.3m, 0.25m, 0.15m, 0.1m, 0.05m), a serem refinados com dados reais. 
A cinemática inversa foi implementada para calcular posições com base nos ângulos das juntas.

 \begin{figure}[h!]
    \centering
	\Caption{\label{fig:Figura-1} Modelo 3D renderizado do Robô}	
	\UNIFORfig{}{
		\fbox{\includegraphics[width=8cm]{figuras/figura-2}}
	}{
		\Fonte{Elaborado pelo autor}			
	}	
\end{figure}

\section{Implementação do Software}

O software foi implementado em C++, com módulos separados:

\begin{alineascomnumero}
    \item Renderização: Carregamento e renderização do modelo 3D usando OpenGL e Assimp.
    \item Input: Gerenciamento de entradas via SDL (teclado, mouse).
    \item Simulação: Cálculo de transformações cinemáticas com GLM e modelagem física para simulação realista.
    \item Interface Gráfica: Exibição e ajuste de parâmetros via ImGui.
\end{alineascomnumero}

Implementando estes algoritmos para cinemática e simulação física:

\begin{alineascomnumero}
\item FABRIK (cinemática inversa de alcance para frente e para trás)
\item GGD (Descida de coordenação cíclica)
\item GJK (Gilbert Johnson Keerthi): Cálculo de colisão para simulação física realista.
\item TSE (Teorema de separação de eixos): Cálculo de colisão para simulação física realista.
\item EPA (Algoritmo de expansão de politopo)
\item Adição de Minkowski: Função suporte para o algoritmo de GJK.
\item Sistemas de arbitração para simulação
\end{alineascomnumero}


%\begin{algorithm}[H]
%	\Entrada{o proprio texto}
%	\Saida{como escrever algoritmos com \LaTeX2e }
%	\Inicio{
%		inicializa\c{c}\~ao\;
%		\Repita{fim do texto}{
%			leia o atual\;
%			\Se{entendeu}{
%				vá para o próximo\;
%				próximo se torna o atual\;}
%			\Senao{volte ao início da seção\;}
%		}
%	}
%	\caption{Exemplo de Algoritmo Versao 02}
%\end{algorithm}

%\begin{algorithm}
%	\begin{algorithmic}
%	\Entrada{o proprio texto}
%	\Saida{como escrever algoritmos com \LaTeX2e }	
%	\end{algorithmic}
%\end{algorithm}

Exemplo de alíneas com números:

%\begin{alineascomnumero}
%	\item Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nunc dictum sed tortor nec viverra.
%	\item Praesent vitae nulla varius, pulvinar quam at, dapibus nisi. Aenean in commodo tellus. Mauris molestie est sed justo malesuada, quis feugiat tellus venenatis.
%	\item Praesent quis erat eleifend, lacinia turpis in, tristique tellus. Nunc dictum sed tortor nec viverra.
%	\item Mauris facilisis odio eu ornare tempor. Nunc dictum sed tortor nec viverra.
%	\item Curabitur convallis odio at eros consequat pretium.
%\end{alineascomnumero}

%\lipsum[12]

\begin{table}[h!]	
	\centering
	\Caption{\label{tab:internal}Internal exon scores}	
	\IBGEtab{}{
		\begin{tabular}{cll}
			\toprule
			Ranking & Exon Coverage & Splice Site Support\\
			\midrule \midrule
			E1 & Complete coverage by a single transcript & Both splice sites\\
			E2 & Complete coverage by more than a single transcript & Both splice sites\\
			E3 & Partial coverage & Both splice sites\\
			E4 & Partial coverage & One splice site\\
			E5 & Complete or partial coverage & No splice sites\\
			E6 & No coverage & No splice sites\\
			\bottomrule
		\end{tabular}
	}{
	\Fonte{os autores}
}
\end{table}

%\lipsum[2] Referenciando a \autoref{tab:internal} \lipsum[2]




\section{Algoritmos e embasamento matemático}

\lipsum[2]

	\begin{equation}
		\begin{aligned}
			x = a_0 + \cfrac{1}{a_1
				+ \cfrac{1}{a_2
					+ \cfrac{1}{a_3 + \cfrac{1}{a_4} } } }
		\end{aligned}
	\end{equation}

\lipsum[3]

	\begin{equation}
		\begin{aligned}
			k_{n+1} = n^2 + k_n^2 - k_{n-1}
		\end{aligned}
	\end{equation}

\lipsum[4]

	\begin{equation}
		\begin{aligned}
			\cos (2\theta) = \cos^2 \theta - \sin^2 \theta
		\end{aligned}
	\end{equation}
	
\lipsum[5]

	\begin{equation}
		\begin{aligned}
			A_{m,n} =
			\begin{pmatrix}
			a_{1,1} & a_{1,2} & \cdots & a_{1,n} \\
			a_{2,1} & a_{2,2} & \cdots & a_{2,n} \\
			\vdots  & \vdots  & \ddots & \vdots  \\
			a_{m,1} & a_{m,2} & \cdots & a_{m,n}
			\end{pmatrix}
		\end{aligned}
	\end{equation}

\lipsum[6]

	\begin{equation}
		\begin{aligned}
			f(n) = \left\{ 
			\begin{array}{l l}
			n/2 & \quad \text{if $n$ is even}\\
			-(n+1)/2 & \quad \text{if $n$ is odd}
			\end{array} \right.
		\end{aligned}
	\end{equation}
	
\lipsum[7]



\subsection{Algoritmos de Simulação Robótica}

Os seguintes algoritmos foram implementados para o software de simulação 3D:

\subsubsection{Algoritmo FABRIK}

O algoritmo FABRIK (Forward and Backward Reaching Inverse Kinematics) é utilizado para resolver o problema de cinemática inversa, determinando os ângulos das juntas necessários para posicionar o efetuador final do robô em uma posição alvo específica. Este algoritmo opera em duas fases: uma fase forward que estende a cadeia cinemática em direção ao alvo, e uma fase backward que ajusta as posições das juntas para manter os comprimentos dos elos constantes, sendo particularmente eficaz por sua simplicidade computacional e capacidade de lidar com múltiplos graus de liberdade em tempo real.

\begin{algorithm}[h!]
	\SetSpacedAlgorithm
	\caption{\label{alg:fabrik}Algoritmo FABRIK - Forward and Backward Reaching Inverse Kinematics}
	\Entrada{posição alvo, posições das juntas, comprimentos dos elos}
	\Saida{ângulos das juntas para alcançar a posição alvo}
	\Inicio{
		\Para{cada iteração}{
			// Fase Forward (para frente)
			posição\_atual $\leftarrow$ posição\_base\;
			\Para{i = 1 até número\_de\_juntas}{
				distância $\leftarrow$ |posição\_alvo - posição\_atual|\;
				\Se{distância > comprimento\_elo[i]}{
					posição\_atual $\leftarrow$ posição\_atual + (comprimento\_elo[i] / distância) * (posição\_alvo - posição\_atual)\;
				}
				\Senao{
					posição\_atual $\leftarrow$ posição\_alvo\;
				}
			}
			// Fase Backward (para trás)
			posição\_atual $\leftarrow$ posição\_alvo\;
			\Para{i = número\_de\_juntas até 1}{
				distância $\leftarrow$ |posição\_anterior - posição\_atual|\;
				\Se{distância > comprimento\_elo[i]}{
					posição\_atual $\leftarrow$ posição\_atual + (comprimento\_elo[i] / distância) * (posição\_anterior - posição\_atual)\;
				}
				\Senao{
					posição\_atual $\leftarrow$ posição\_anterior\;
				}
			}
		}
		calcular\_ângulos\_das\_juntas()\;
	}	
\end{algorithm}

\subsubsection{Algoritmo GGD}

O algoritmo GGD (Gradient Descent com Coordenação Cíclica) é empregado para otimização de parâmetros e ajuste fino dos movimentos, permitindo ajustar automaticamente os parâmetros do sistema como velocidades e acelerações para melhorar a suavidade e precisão dos movimentos simulados, sendo especialmente útil para encontrar configurações ótimas que minimizem o consumo de energia ou maximizem a eficiência dos movimentos do robô.

\begin{algorithm}[h!]
	\SetSpacedAlgorithm
	\caption{\label{alg:ggd}Algoritmo GGD - Gradient Descent com Coordenação Cíclica}
	\Entrada{função objetivo, parâmetros iniciais, taxa de aprendizado}
	\Saida{parâmetros otimizados}
	\Inicio{
		parâmetros $\leftarrow$ parâmetros\_iniciais\;
		\Repita{convergência}{
			gradiente $\leftarrow$ calcular\_gradiente(parâmetros)\;
			\Para{cada parâmetro i}{
				parâmetros[i] $\leftarrow$ parâmetros[i] - taxa\_aprendizado * gradiente[i]\;
			}
			erro $\leftarrow$ calcular\_erro(parâmetros)\;
			\Se{erro < threshold}{
				parar\;
			}
		}
	}	
\end{algorithm}

\subsubsection{Algoritmo GJK}

O algoritmo GJK (Gilbert Johnson Keerthi) é responsável pela detecção rápida de colisões, garantindo que o robô não atravesse objetos ou se auto-intersecte durante os movimentos, utilizando conceitos de geometria computacional e análise de simplex para detectar se dois objetos estão em colisão de forma altamente eficiente e em tempo real, permitindo simulações fluidas mesmo com múltiplos objetos no ambiente.

\begin{algorithm}[h!]
	\SetSpacedAlgorithm
	\caption{\label{alg:gjk}Algoritmo GJK - Gilbert Johnson Keerthi para Detecção de Colisão}
	\Entrada{objeto A, objeto B}
	\Saida{colisão detectada (verdadeiro/falso)}
	\Inicio{
		simplex $\leftarrow$ $\emptyset$\;
		direção $\leftarrow$ direção\_inicial\;
		\Repita{simplex contém origem}{
			ponto\_suporte $\leftarrow$ suporte(A, B, direção)\;
			\Se{ponto\_suporte $\cdot$ direção $\leq$ 0}{
				retornar falso\;
			}
			simplex $\leftarrow$ adicionar\_ponto(simplex, ponto\_suporte)\;
			simplex, direção $\leftarrow$ reduzir\_simplex(simplex)\;
		}
		retornar verdadeiro\;
	}	
\end{algorithm}

\subsubsection{Algoritmo EPA}

O algoritmo EPA (Expanding Polytope Algorithm) complementa o GJK calculando informações detalhadas sobre colisões, incluindo a distância de penetração e o vetor de separação, sendo essencial para implementar respostas realistas a colisões como separação automática de objetos ou alertas visuais para o usuário, trabalhando em conjunto com o GJK para fornecer uma solução completa ao problema de detecção e resolução de colisões.

\begin{algorithm}[h!]
	\SetSpacedAlgorithm
	\caption{\label{alg:epa}Algoritmo EPA - Expanding Polytope Algorithm}
	\Entrada{simplex do GJK}
	\Saida{vetor de separação e distância de penetração}
	\Inicio{
		polítopo $\leftarrow$ simplex\;
		\Repita{polítopo não pode ser expandido}{
			aresta\_mais\_próxima $\leftarrow$ encontrar\_aresta\_mais\_próxima\_da\_origem(polítopo)\;
			ponto\_suporte $\leftarrow$ suporte(A, B, normal\_da\_aresta)\;
			distância $\leftarrow$ |ponto\_suporte $\cdot$ normal\_da\_aresta|\;
			\Se{|distância - distância\_anterior| < epsilon}{
				retornar normal\_da\_aresta, distância\;
			}
			polítopo $\leftarrow$ adicionar\_ponto(polítopo, ponto\_suporte)\;
		}
	}	
\end{algorithm}

\section{Usando Código-fonte}

\lipsum[10]

\lstinputlisting[language=C++,caption={Hello World em C++}]{figuras/main.cpp}

\lipsum[11]

\begin{lstlisting}[language=Java,caption={Hello World em Java}]
public class HelloWorld {
	public static void main(String[] args) {
		System.out.println("Hello World!");
	}
}
\end{lstlisting}

\lipsum[11]

\section{Usando Teoremas, Proposições, etc}

Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nunc dictum sed tortor nec viverra. consectetur adipiscing elit. Nunc dictum sed tortor nec viverra.

\begin{teo}[Pitágoras]
	Em todo triângulo retângulo o quadrado do comprimento da
	hipotenusa é igual a soma dos quadrados dos comprimentos dos catetos.
\end{teo}


Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nunc dictum sed tortor nec viverra. consectetur adipiscing elit. Nunc dictum sed tortor nec viverra.

\begin{teo}[Fermat]
	Não existem inteiros $n > 2$, e $x, y, z$ tais que $x^n + y^n = z$
\end{teo}

Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nunc dictum sed tortor nec viverra. consectetur adipiscing elit. Nunc dictum sed tortor nec viverra.

\begin{prop}
	Para demonstrar o Teorema de Pitágoras...
\end{prop}

Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nunc dictum sed tortor nec viverra. consectetur adipiscing elit. Nunc dictum sed tortor nec viverra.

\begin{exem}
	Este é um exemplo do uso do ambiente exe definido acima.
\end{exem}

Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nunc dictum sed tortor nec viverra. consectetur adipiscing elit. Nunc dictum sed tortor nec viverra.

\begin{xdefinicao}
	Definimos o produto de ...
\end{xdefinicao}

Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nunc dictum sed tortor nec viverra. consectetur adipiscing elit. Nunc dictum sed tortor nec viverra.

\section{Usando Questões}


Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nunc dictum sed tortor nec viverra. consectetur adipiscing elit. Nunc dictum sed tortor nec viverra.

\begin{questao}
	\item Esta é a primeira questão com alguns itens:
		\begin{enumerate}
			\item Este é o primeiro item
			\item Segundo item
		\end{enumerate}
	\item Esta é a segunda questão:
		\begin{enumerate}
			\item Este é o primeiro item
			\item Segundo item
		\end{enumerate}
	\item Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nunc dictum sed tortor nec viverra. consectetur adipiscing elit. Nunc dictum sed tortor nec viverra.
		\begin{enumerate}
			\item consectetur
			\item adipiscing
			\item Nunc
			\item dictum
		\end{enumerate}
\end{questao}

\section{Citações}

\subsection{Documentos com três autores}

Quando houver três autores na citação, apresentam se os três, separados por ponto e vírgula, caso estes estejam após o texto. Se os autores estiverem incluídos no texto, devem ser separados por vírgula e pela conjunção "e".

\citeautoronline{tresautores}

\cite{tresautores}

\subsection{Documentos com mais de três autores}
Havendo mais de três autores, indica-se o primeiro seguido da expressão \textit{et al.} (do latim \textit{et alli}, que significa e outros), do ano e da página.

\citeautoronline{quatroautores}

\cite{quatroautores}

\subsection{Documentos de vários autores}

Havendo    citações    indiretas de    diversos    documentos    de    vários    autores, mencionados  simultaneamente e  que  expressam  a  mesma  ideia,  separam-se  os  autores  por ponto e vírgula, em ordem alfabética.

\cite{tresautores, quatroautores}

\section{Notas de Rodap\'{e}}

Deve-se utilizar o sistema autor-data para as  citações no texto e o numérico para notas explicativas\footnote{Veja - se como exemplo desse tipo de abordagem o estudo de Netzer (1976)}. As notas de rodapé podem e devem ser alinhadas, a partir da segunda linha da mesma nota, abaixo da primeira letra da primeira palavra, de forma a destacar o expoente \footnote{Encontramos  esse  tipo  de  perspectiva  na  2ª  parte  do  verbete  referido  na  nota  anterior,  em  grande  parte  do estudo de Rahner (1962).} e sem espaço entre elas e com fonte menor (tamanho 10).

